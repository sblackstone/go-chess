
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>boardstate: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/sblackstone/go-chess/boardstate/bitopts.go (100.0%)</option>
				
				<option value="file1">github.com/sblackstone/go-chess/boardstate/boardstate.go (100.0%)</option>
				
				<option value="file2">github.com/sblackstone/go-chess/boardstate/debugutils.go (0.0%)</option>
				
				<option value="file3">github.com/sblackstone/go-chess/boardstate/meta.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package boardstate

func setBit(n uint64, pos uint8) uint64 <span class="cov8" title="1">{
  n |= (1 &lt;&lt; pos)
  return n
}</span>

func clearBit(n uint64, pos uint8) uint64 <span class="cov8" title="1">{
    var mask uint64 = ^(1 &lt;&lt; pos)
    n &amp;= mask
    return n
}</span>

func testBit(n uint64, pos uint8) bool <span class="cov8" title="1">{
    return n &amp; (1 &lt;&lt; pos) &gt; 0;
}</span>

func flipBit(n uint64, pos uint8) uint64 <span class="cov8" title="1">{
  n ^= (1 &lt;&lt; pos)
  return n
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package boardstate


// gridToLinear maps (i,j) -&gt; n
func gridToLinear(i uint8, j uint8) uint8 <span class="cov8" title="1">{
        return i*8 + j
}</span>

// BoardState contains the state of the Board
type BoardState struct {
        colors []uint64
        pieces []uint64
        meta   uint64 // really could be int32 but we don't want to have to write 32 and 64 bit versions of our bit library.
        //wpassant   int8 // 8 bits needed
        //bpassant   int8 // 8 bits needed
        //turn       int8 // 1 bit needed
        //wcastle    int8 // 2 bits needed
        //bcastle    int8 // 2 bits needed
}

// Blank returns a blank board with no pieces on it
func Blank() *BoardState <span class="cov8" title="1">{
        b := BoardState{}
        b.colors = []uint64{0, 0}
        b.pieces = []uint64{0, 0, 0, 0, 0, 0}
        return &amp;b
}</span>

// Initial returns a board with the initial setup.
func Initial() *BoardState <span class="cov8" title="1">{
        b := BoardState{}
        // These constants are pre-calculated using InitialManual (see below)...
        b.colors = []uint64{18446462598732840960, 65535 }
        b.pieces = []uint64{9295429630892703873, 4755801206503243842, 2594073385365405732, 576460752303423496, 1152921504606846992, 71776119061282560}
        return &amp;b
}</span>

// initialManual sets up the board manually, only used to calculate the constants for the fast version Initial.
func initialManual() *BoardState <span class="cov8" title="1">{
        var j uint8

        b := Blank()

        backFile := []uint8{ROOK, KNIGHT, BISHOP, QUEEN, KING, BISHOP, KNIGHT, ROOK}
        for j = 0; j &lt; 8; j++ </span><span class="cov8" title="1">{
                b.SetSquareXY(0, j, BLACK, backFile[j])
                b.SetSquareXY(7, j, WHITE, backFile[j])

                b.SetSquareXY(1, j, BLACK, PAWN)
                b.SetSquareXY(6, j, WHITE, PAWN)
        }</span>
        <span class="cov8" title="1">return b</span>
}

// ColorOfSquare returns WHITE,BLACK, or EMPTY
func (b *BoardState) ColorOfSquare(n uint8) uint8 <span class="cov8" title="1">{
        if testBit(b.colors[WHITE], n) </span><span class="cov8" title="1">{
                return WHITE
        }</span>
        <span class="cov8" title="1">if testBit(b.colors[BLACK], n) </span><span class="cov8" title="1">{
                return BLACK
        }</span>
        <span class="cov8" title="1">return EMPTY</span>
}

// PieceOfSquare t
func (b *BoardState) PieceOfSquare(n uint8) uint8 <span class="cov8" title="1">{
        var i uint8
        for i = 0; i &lt; 6; i++ </span><span class="cov8" title="1">{
                if testBit(b.pieces[i], n) </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return EMPTY</span>
}

// SetSquare removes any existing piece and sets the square to the new piece/color.
func (b *BoardState) SetSquare(n uint8, color uint8, piece uint8) <span class="cov8" title="1">{
        // Theres gotta be room for improvement here...
        // we really only need to update the bitboard that is currently set.
        b.pieces[ROOK]    = clearBit(b.pieces[ROOK],   n)
        b.pieces[BISHOP]  = clearBit(b.pieces[BISHOP], n)
        b.pieces[KNIGHT]  = clearBit(b.pieces[KNIGHT], n)
        b.pieces[QUEEN]   = clearBit(b.pieces[QUEEN],  n)
        b.pieces[KING]    = clearBit(b.pieces[KING],   n)
        b.pieces[PAWN]    = clearBit(b.pieces[PAWN],   n)
        b.colors[WHITE]   = clearBit(b.colors[WHITE],  n)
        b.colors[BLACK]   = clearBit(b.colors[BLACK],  n)
        b.colors[color]   = setBit(b.colors[color], n)
        b.pieces[piece]   = setBit(b.pieces[piece], n)
}</span>

// SetSquareXY removes any existing piece and sets the square to the new piece/color with (x,y) coordinates.
func (b *BoardState) SetSquareXY(i uint8, j uint8, color uint8, piece uint8) <span class="cov8" title="1">{
        b.SetSquare(gridToLinear(i, j), color, piece);
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package boardstate

import (
        "fmt"
)

// Print outputs a debug display of the current board.
func (b *BoardState) Print() <span class="cov0" title="0">{
        pieces := make([][]string, 2)
        pieces[BLACK] = []string{"♖", "♘", "♗", "♕", "♔", "♙"};
        pieces[WHITE] = []string{"♜", "♞", "♝", "♛", "♚", "♟"};
        var i, j uint8
        for i = 0; i &lt; 8; i++ </span><span class="cov0" title="0">{
                for j = 0; j &lt; 8; j++ </span><span class="cov0" title="0">{
                        color := b.ColorOfSquare(gridToLinear(i, j))
                        if color == EMPTY </span><span class="cov0" title="0">{
                                fmt.Printf(" - ")
                        }</span> else<span class="cov0" title="0"> {
                                piece := b.PieceOfSquare(gridToLinear(i, j))
                                fmt.Printf(" %s ", pieces[color][piece])
                        }</span>
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package boardstate

/*

// All fields on an initial board should be 0 so no initializiation is necessary.

Bit
0      Turn                      (White = 0, Black = 1)
1      White Castling Short      (Available = 0, Unavailalbe = 1)
2      White Castling Long
3      Black Castling Short
4      Black Castling Long
5-12   Enpassant state after last move  (Set = pawn pushed in that file by opposing color)

*/

const (
  TURN = iota
)

const (
  CASTLE_SHORT = iota
  CASTLE_LONG
)


func (b *BoardState) GetTurn() uint8 <span class="cov8" title="1">{
  if testBit(b.meta, TURN) </span><span class="cov8" title="1">{
    return BLACK
  }</span> else<span class="cov8" title="1"> {
    return WHITE
  }</span>
}

func (b *BoardState) SetTurn(color uint8) <span class="cov8" title="1">{
  if color == WHITE </span><span class="cov8" title="1">{
    b.meta = clearBit(b.meta, TURN)
  }</span> else<span class="cov8" title="1"> {
    b.meta = setBit(b.meta, TURN)
  }</span>
}

func (b *BoardState) ToggleTurn() <span class="cov8" title="1">{
  b.meta = flipBit(b.meta, TURN)
}</span>

func castleBit(color uint8, side uint8) uint8 <span class="cov8" title="1">{
  // WHITE = 0, BLACK = 1
  // SHORT = 0 LONG = 1
  // So,
  // WHITE SHORT = 1 + (2*0) + 0 = 1
  // WHITE LONG  = 1 + (2*0) + 1 = 2
  // BLACK SHORT = 1 + (2*1) + 0 = 3
  // BLACK LONG  = 1 + (2*2) + 1 = 4
  return  1 + (color * 2) + side;
}</span>

func (b *BoardState) ClearEnpassant() <span class="cov8" title="1">{
  b.meta = b.meta &amp; 0b1111111111111111111111111111111111111111111111111110000000011111
}</span>

// SetEnpassant takes a file 0-7 and saves the enpassant state.
func (b *BoardState) SetEnpassant(file uint8) <span class="cov8" title="1">{
  b.ClearEnpassant()
  b.meta = setBit(b.meta, 5 + file)
}</span>

// IsEnpassant takes a file 0-7 and returns the enpassant state.
func (b *BoardState) IsEnpassant(file uint8) bool <span class="cov8" title="1">{
  return testBit(b.meta, 5 + file)
}</span>

func (b *BoardState) HasCastleRights(color uint8, side uint8) bool <span class="cov8" title="1">{
  return !testBit(b.meta, castleBit(color, side))
}</span>

func (b *BoardState) SetCastleRights(color uint8, side uint8, enabled bool) <span class="cov8" title="1">{
  bit := castleBit(color, side)
  if enabled </span><span class="cov8" title="1">{
    b.meta = clearBit(b.meta, bit)
  }</span> else<span class="cov8" title="1"> {
    b.meta = setBit(b.meta, bit)
  }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
